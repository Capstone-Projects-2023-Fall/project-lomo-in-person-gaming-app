"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[598],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),i=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=i(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=i(n),f=r,m=p["".concat(c,".").concat(f)]||p[f]||d[f]||o;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:r,s[1]=l;for(var i=2;i<o;i++)s[i]=n[i];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},1069:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>i});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},s="React API calls and State",l={unversionedId:"react-api-calls-and-state",id:"react-api-calls-and-state",title:"React API calls and State",description:"State allows components to manage and update their own data. Unlike props, which are passed from parent to child and are read-only, state is mutable and controlled by the component itself.",source:"@site/resources/react-api-calls-and-state.md",sourceDirName:".",slug:"/react-api-calls-and-state",permalink:"/project-lomo-in-person-gaming-app/resources/react-api-calls-and-state",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Introduction",permalink:"/project-lomo-in-person-gaming-app/resources/intro"},next:{title:"Docker Quick Start",permalink:"/project-lomo-in-person-gaming-app/resources/docker-quick-start"}},c={},i=[{value:"useState()",id:"usestate",level:2},{value:"useEffect()",id:"useeffect",level:2},{value:"Dependency Array",id:"dependency-array",level:3},{value:"Handling State Changes",id:"handling-state-changes",level:3},{value:"Performing Side Effects (API Calls)",id:"performing-side-effects-api-calls",level:3}],u={toc:i};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"react-api-calls-and-state"},"React API calls and State"),(0,r.kt)("p",null,"State allows components to manage and update their own data. Unlike props, which are passed from parent to child and are read-only, state is mutable and controlled by the component itself."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useState")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect")," are two fundamental hooks in React that allow you to manage state and perform side effects in components."),(0,r.kt)("h2",{id:"usestate"},"useState()"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"useState")," is used to manage state in functional components. It returns an array with two elements: the current state value and a function to update it.")),(0,r.kt)("p",null,"In this example, we're using ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," to maintain the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," state, and when the button is clicked, it updates the state value in real-time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import React, { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;\n")),(0,r.kt)("h2",{id:"useeffect"},"useEffect()"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"useEffect")," is used to perform side effects in components. It takes two arguments: a function to run and an array of dependencies. The function runs when the component mounts and whenever any of the dependencies change.")),(0,r.kt)("p",null,"How to use in a component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import React, { useState } from 'react';\n\nconst MyComponent = () => {\n    useEffect(() => {\n        // code here\n    }, []);\n\n    return ();\n}\n\nexport default Counter;\n")),(0,r.kt)("h3",{id:"dependency-array"},"Dependency Array"),(0,r.kt)("p",null,"When you provide a dependency array as the second argument to useEffect, React will monitor the values in that array. If any of those values change between renders, React will re-run the code inside the useEffect."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"const [count, setCount] = useState(0);\n\nuseEffect(() => {\n    // This code will run when the component mounts and whenever 'count' changes.\n    console.log('Count has changed.');\n}, [count]);\n\nreturn (\n    <div>\n        <p>Count: {count}</p>\n        <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n);\n")),(0,r.kt)("h3",{id:"handling-state-changes"},"Handling State Changes"),(0,r.kt)("p",null,"You can use useEffect to handle state changes and update the UI accordingly. For example, if you have a counter and you want to display a message when the count changes, you can put the code to update the message inside a useEffect that depends on the count state variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"const [count, setCount] = useState(0);\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n    // This code runs whenever 'count' changes\n    setMessage(`Count is now: ${count}`);\n}, [count]);\n\nreturn(\n    <div>{message}</div>\n);\n")),(0,r.kt)("h3",{id:"performing-side-effects-api-calls"},"Performing Side Effects (API Calls)"),(0,r.kt)("p",null,"Besides updating the UI, useEffect is commonly used for performing side effects like ",(0,r.kt)("strong",{parentName:"p"},"making API requests"),", setting up subscriptions, or manipulating the DOM. For example, you can use it to fetch data from an API and update the component's state with the received data."),(0,r.kt)("p",null,"All routes created in the ",(0,r.kt)("inlineCode",{parentName:"p"},"api.php")," file will build on the ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/")," route. For example, the full '/hello' route will be https://localhost/api/hello. On the frontend, it will be called using only the subpage url ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/hello"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'// MyComponent.js\n\nimport { useEffect, useState } from \'react\'\n\nfunction MyComponent() => {\n    const [hello, setHello] = useState("hello");\n\n    useEffect(() => {\n        // http request options \n        var requestOptions = {\n            method: \'GET\',\n            headers: {\n                "Accept": "application/json" // MUST SEND WITH THIS\n            },\n        };\n        \n        // call the API using fetch, a builtin http-request package\n        // if we use a different http-request package, we can just use that\n        // the point is that api calls must be in the useEffect() function\n        fetch("http://localhost/api/hello", requestOptions)\n            .then(response => response.json())\n            .then(response => {\n                let message = JSON.stringify(response.message);\n                console.log(message);\n                setHello(message);\n            })\n            .catch(error => console.log(\'error\', error));\n    }, []);\n\n    return (\n        <>\n            {hello} // display the response\n        </>\n    )\n}\nexport default MyComponent\n')))}p.isMDXComponent=!0}}]);